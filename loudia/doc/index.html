<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Loudia: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Loudia Documentation</h1>
<p>
<h3 align="center">0.1 </h3><dl class="author" compact><dt><b>Author:</b></dt><dd>Ricard Marxer</dd></dl>
Loudia is a C++ library with Python bindings. It is used to create audio applications.<p>
Loudia is specially targeted for researchers. The algorithms are not necessarily tuned for performance but rather for: Ease of use Flexibility and clarity of the algorithms Variety of algorithms<p>
<h2>Features</h2>
<p>
The following algorithms are implemented:<p>
<ul>
<li><a class="el" href="classWindow.html" title="Algorithm to create and apply several type of windows on vectors of Real or Complex...">Window</a></li><li><a class="el" href="classUnwrap.html" title="Algorithm to unwrap phases vectors represented as vectors of Real values.">Unwrap</a></li><li>Fast Fourier Transform (<a class="el" href="classFFT.html" title="Algorithm to perform a Fast Fourier Transform of a vector of Real values.">FFT</a> / <a class="el" href="classIFFT.html" title="Algorithm to perform an Inverse Fast Fourier Transform of a vector of Complex values...">IFFT</a>) (wrapper around libfftw [<a href="http://www.fftw.org/">http://www.fftw.org/</a>])</li><li>Discrete Cosine Transform (<a class="el" href="classDCT.html" title="Algorithm to perform a Discrete Cosine Transform of a vector of Real values.">DCT</a>)</li><li><a class="el" href="classFilter.html" title="Algorithm to apply one or several IIR filters given the Real value coefficients.">Filter</a> and <a class="el" href="classBandFilter.html" title="Algorithm to create and apply several types of low pass, high pass, band pass and...">BandFilter</a> (based on Scipy implementation):<ul>
<li>Band type<ul>
<li>LowPass</li><li>HighPass</li><li>BandPass</li><li>BandStop</li></ul>
</li><li><a class="el" href="classFilter.html" title="Algorithm to apply one or several IIR filters given the Real value coefficients.">Filter</a> type<ul>
<li>Chebyshev I</li><li>Chebyshev II</li><li>Bessel</li><li>Butterworth</li></ul>
</li></ul>
</li><li><a class="el" href="classCorrelation.html" title="Algorithm to perform the correlation between two vectors of Real values.">Correlation</a> / <a class="el" href="classAutocorrelation.html" title="Algorithm to perform an autocorrelation of vectors of Real values.">Autocorrelation</a><ul>
<li>Direct calculation</li><li><a class="el" href="classFFT.html" title="Algorithm to perform a Fast Fourier Transform of a vector of Real values.">FFT</a> based calculation</li></ul>
</li><li><a class="el" href="classResample.html" title="Algorithm to resample vectors represented as vectors of Real values.">Resample</a> (wrapper around libsamplerate [<a href="http://www.mega-nerd.com/SRC/">http://www.mega-nerd.com/SRC/</a>])</li><li>Onset Detection Functions:<ul>
<li>High Frequency Content (HFC)</li><li>Flux</li><li>Phase Deviation</li><li>Complex Domain</li><li>Modified Kullback-Liebler</li><li>Peak Center of Gravity</li></ul>
</li><li>Pitch Estimation:<ul>
<li><a class="el" href="classAutocorrelation.html" title="Algorithm to perform an autocorrelation of vectors of Real values.">Autocorrelation</a> Function based (ACF)</li><li>Inverse Problem based</li></ul>
</li><li>Spectral <a class="el" href="classBands.html" title="Algorithm to calculate the sum of values in a given set of weighted bands.">Bands</a><ul>
<li>Mel bands</li></ul>
</li><li><a class="el" href="classMFCC.html" title="Algorithm to calculate the Mel-frequency Cepstrum Coefficients of vectors of Real...">MFCC</a></li><li><a class="el" href="classLPC.html" title="Algorithm to calculate the Linear Predictive Coding of vectors of Real values.">LPC</a></li><li>Sinusoidal Modelling:<ul>
<li>Peak Detection</li><li>Peak Interpolation</li><li>Peak Tracking</li></ul>
</li><li>Spectral Whitening</li><li>Spectral Noise Suppression</li><li>Non-negative Matrix Factorization (<a class="el" href="classNMF.html" title="Algorithm to calculate the Non-negative Matrix Factorization of a matrix of Real...">NMF</a>)</li><li>Other experimental and/or unfinished algorithm implementations<ul>
<li>Spectral Reassignment</li><li>Adaptative Optimized Kernel (AOK) (modification of AOK 4.1 [<a href="http://www.macunix.net/aok.html">http://www.macunix.net/aok.html</a>])</li><li>Peak Synthesis</li><li>Incremental Non-negative Matrix Factorization (INMF)</li><li><a class="el" href="classLPC.html" title="Algorithm to calculate the Linear Predictive Coding of vectors of Real values.">LPC</a> residual</li></ul>
</li></ul>
<p>
Numerous examples which can also be used for testing in some cases can be found in python/ Some of the examples require an audio WAVE filename as input argument.<p>
<h2>Dependencies</h2>
<p>
The C++ library Libaudio requires:<ul>
<li>At run time:<ul>
<li>libsamplerate-dev &gt;=0.1.3</li><li>libfftw3-dev &gt;=3.1.2</li></ul>
</li><li>At compile time:<ul>
<li>gcc</li><li>python &gt;=2.5</li></ul>
</li></ul>
<p>
The Python bindings Libaudio require:<ul>
<li>At run time:<ul>
<li>numpy</li></ul>
</li><li>At compile time:<ul>
<li>swig</li><li>numpy-dev</li><li>python-dev</li></ul>
</li></ul>
<p>
Libaudio uses a template library called Eigen (<a href="http://eigen.tuxfamily.org">http://eigen.tuxfamily.org</a>).<p>
In C++ all algorithms use Eigen::Matrix types as inputs and outputs.<p>
In the Python bindings use Numpy arrays as inputs and outputs.<p>
<h2>Build and installation</h2>
<p>
To build and install Loudia run: <pre>
./waf configure --prefix=/some/install/dir
./waf build
sudo ./waf install
</pre><p>
To uninstall it run: <pre>
sudo ./waf uninstall
</pre><p>
Several options allow different building modes.<p>
To build without Python bindings run: <pre>
./waf configure --no-python-bindings
./waf build
</pre><p>
To build the documentation run: <pre>
./waf configure --doc
./waf build
</pre><p>
To build in debug mode run: <pre>
./waf configure --debug
./waf build
</pre><p>
All the above options can be combined.<p>
<h2>Overview</h2>
<p>
The library is composed by algorithms. Algorithms are classes that represent a processing unit.<p>
All algorithms share two methods:<ul>
<li>setup()</li><li>reset()</li></ul>
<p>
Additionally a method called process() is also always present. Depending on the algorithm the method will take different number and types of arguments.<p>
The algorithms return the results in a C-style way. The process() method also takes as input arguments pointers to matrices where the results will be written.<p>
All inputs and outputs to the process() methods are of type Eigen::Matrix.<p>
<h2>Quick howto</h2>
<p>
From Python you may create algorithm, change its parameters and call the process method:<p>
<pre>
import numpy
import pylab
import loudia</pre><p>
<pre>data_frame = numpy.arange( 128 )</pre><p>
<pre>fft = loudia.FFT()
fft.setFftSize( 128 )</pre><p>
<pre>result = fft.process( data_frame )
pylab.plot( result[0,:] ) # Note that the results of the <a class="el" href="classFFT.html" title="Algorithm to perform a Fast Fourier Transform of a vector of Real values.">FFT</a> algorithm are stacked in rows (we only plot the first)</pre><p>
<pre># When setting several parameters we might not want the algorithm to reconfigure itself
# method after each parameter setting, and we will call the setup() manually 
fft.setFftSize( 256, False )
fft.setZeroPhase( True, False )
fft.setup()</pre><p>
<pre>result = fft.process( data_frame )
pylab.plot( abs( result[0,:] ) ) # Note that the results of the <a class="el" href="classFFT.html" title="Algorithm to perform a Fast Fourier Transform of a vector of Real values.">FFT</a> algorithm are stacked in rows (we only plot the first)</pre><p>
<pre>pylab.show()
</pre><p>
<h2>Limitations</h2>
<p>
A few assumptions are used when using the library:<ul>
<li>Loudia has no algorithm for loading audio frames</li></ul>
<p>
<ul>
<li>All algorithms take Eigen::Matrix types as inputs and outputs in the process() methods</li></ul>
<p>
<ul>
<li>Loudia does NOT have a streaming mode. All algorithms mantain a state which can be reset using reset(). And the process() methods may act on preallocated matrices. Therefore with the use of Eigen::Map, Loudia can be used inside streaming libraries that expose the buffers. </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Mar 31 20:38:32 2009 for Loudia by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
